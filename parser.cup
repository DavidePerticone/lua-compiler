/*
Implemented:
-Single global variable initialization with a NUMBER or with another var


NOTICE: for now, inside the functions we can just declare local variables.

*/

import java_cup.runtime.*;
import java.io.*;
import java.util.HashMap;
import java.util.Map.*;
import java.util.ArrayList;
import java.util.regex.*;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;


init with {:
   currentSymTable = new parser.SymbolTable(null); //Main symbol table for global variables included in all scopes
   funcBuffer = new StringBuffer(); //buffer for function declaration
   globalDecBuffer = new StringBuffer(); //buffer for global var declaration
   mainBuffer = new StringBuffer(); //buffer used for main function
   bwr = new BufferedWriter(new FileWriter(new File("output.ll"))); //output file
   registerCount = 1; //used as counter for SSA registers
   /*Structure:
   Global buffer
   Function buffer
   main buffer


   */
:};


parser code {:
    
public SymbolTable currentSymTable;
public StringBuffer funcBuffer;
public StringBuffer globalDecBuffer;
public StringBuffer mainBuffer;
public BufferedWriter bwr;
public Integer registerCount;
 public enum Type {NUMBER, TABLE, IMMEDIATE}; //different types of values NUMBER means that the value is assigned to a var and is of type NUMBER, IMMEDIATE means it is a immediate read from file

 public class SymbolTable{
        public ArrayList<ValueObj> varList;
        public ArrayList<ValueObj> expList;
        public HashMap<String, ValueObj> varTable;
        public int nargs;

        SymbolTable prev;

        public SymbolTable(SymbolTable p){
            this.varTable = new HashMap<String, ValueObj>();
            this.varList = new ArrayList<ValueObj>();
            this.expList = new ArrayList<ValueObj>();
            this.nargs = 0;
            this.prev = p;
        }

        public ValueObj get(String s){
            for (SymbolTable sym = this; sym != null; sym = sym.prev){
                ValueObj found = sym.varTable.get(s);
                if (found != null)
                    return found;
            }
            return null;
        }
    }


 public class ValueObj {

		Double value;
        public String name;
        public Type type;
        public String scope;

		public ValueObj(String name) {
			super();
			this.name = name;
            type = null;
		}

        public ValueObj(Double value){
            this.value=value;
            type = Type.IMMEDIATE;
        }

        public void setDouble(){
            this.type= Type.NUMBER;
        }

        public void setGlobal(){
            scope="@";
        }

        public void setLocal(){
            scope="%";
        }

        
  
 
    }


:};





action code {:

  public void appendFuncBuffer(String s, boolean newLine){
        funcBuffer.append(s);
        if (newLine)
            funcBuffer.append("\n");
    }

     public void appendGlobalDecBuffer(String s, boolean newLine){
        globalDecBuffer.append(s);
        if (newLine)
            globalDecBuffer.append("\n");
    }

     public void appendMainBuffer(String s, boolean newLine){
       mainBuffer.append(s);
        if (newLine)
            mainBuffer.append("\n");
    }

    public String getRegister(){
        return String.valueOf(registerCount++);
    }

    public String createGlovalVarLLVM(String name, String type, String value){

            return "@"+name+" = " +"global "+type+" "+value+ ", align 8";

    }

    public String storeLLVM(String source, String sourceType, String dest, String destType, String align){
          //  store i32 %4, i32* %3, align 4
          return "store " + sourceType +" " + source+ ", " + destType+"* "+dest+", align " +align;

    }

    public String loadLLVM(String outName, String outType, String inputType, String inputName, String align ){
        // %2 = load double, double* @b, align 8

        return outName+" = " + "load " + outType+", "+inputType+"* "+inputName+", "+"align "+align;

    }

    public void initVar(ValueObj n, ValueObj x){
                                    //if the variable has never been used before, it means that must be declared
                        if(n.type == null && x.type == Type.IMMEDIATE){ //if the value to which initiliaze is an immediate
                            
                            n.setDouble(); //set type number in the variable
                            n.setGlobal();
                            //@X = global i32 17
                            //createGlovalVarLLVM(String name, String type, String value){
                            System.out.println(createGlovalVarLLVM(n.name, "double", ""+x.value));
                            appendGlobalDecBuffer(createGlovalVarLLVM(n.name, "double", ""+x.value), true); //append to the Global declaration buffer

                        }else if(n.type == Type.NUMBER && x.type == Type.IMMEDIATE){ //if type is not null, it has been already declared and must be loaded with a new value
                                //store double 6.000000e+00, double* @a, align 8
                               
                                
                                 appendMainBuffer( storeLLVM(""+x.value, "double", n.scope+n.name, "double", "8"), true); //load with a new value
                        }else if(n.type == null && x.type == Type.NUMBER){ //if new var is undeclared and we initialize with a variable already declared
                                 n.setDouble(); //set type number in the variable
                                 n.setGlobal();
                                appendGlobalDecBuffer(createGlovalVarLLVM(n.name, "double", "0.0"), true); //append to  the Global declaration buffer
                                //(String outName, String outType, String inputType, String inputName, String align )
                                String reg = getRegister(); //get a new register
                                appendMainBuffer(loadLLVM("%"+reg, "double", "double", x.scope+x.name,"8"), true); //save the value of the var into the register
                                appendMainBuffer( storeLLVM("%"+reg, "double", n.scope+n.name, "double", "8"), true); //store new var with value pointed by the variable
                        }else if(n.type == Type.NUMBER && x.type == Type.NUMBER){ //if both var have already been declared and we want to assigne one to the other
                                  String reg = getRegister();
                                 appendMainBuffer(loadLLVM("%"+reg, "double", "double", x.scope+x.name,"8"), true);
                                 appendMainBuffer(storeLLVM("%"+reg, "double", x.scope+n.name, "double", "8"), true); 
                        }


    }
:}




//Terminal tokens
terminal MIN, UMIN, MAJ, MIN_EQ, MAJ_EQ, AND, OR, NOT, SO, SC, EQ, NOTEQ;
terminal RO, RC, BO, BC, PLUS, MINUS, STAR, DIV, HAT, CM;
terminal DO, FOR, IF, ELSE, THEN, END, LOCAL;
terminal  STRING, NIL;
terminal WHILE, REPEAT, UNTIL, FUNCTION, RETURN, PRINT;
terminal String ID;
terminal Double NUMBER;
//Non terminal tokens
non terminal global_var_init, local_var, block, array_dec;
non terminal  local_var_init, local_var_list, var_list, ass_list;
non terminal for_loop, stmt_list, stmt, loop_cond, assignment;
non terminal while_loop, repeat_loop, if_block, else_block, ret;
non terminal print_func_args, func_list, instr_list, prog, finish, function_decl, print_func, func_param_list, func_call, declaration;
non terminal ValueObj var;
non terminal ValueObj ass_exp, exp;

//Precedences
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left MIN, MAJ, MIN_EQ, MAJ_EQ, EQ, NOTEQ;
precedence left PLUS, MINUS;
precedence left STAR, DIV;
precedence left NOT, UMIN;
precedence right HAT;

/***********************/
/**** GRAMMAR START ****/
/***********************/
start with prog;


prog ::= func_list {:

       

:}  stmt_list  {:
		 bwr.write(globalDecBuffer.toString());
	    bwr.write("define void @main(){\n");
        bwr.write(mainBuffer.toString());
	
	
		bwr.write("ret void\n}");
		bwr.flush();
 
		//close the stream
		bwr.close();
	
	
	
:};


/*****************************/
/**** DECLARATIONS ****/
/*****************************/

declaration ::= local_var_init | local_var_list | global_var_init | assignment;


/**********************/
/**** INSTRUCTIONS ****/
/**********************/



stmt_list ::= stmt_list stmt | stmt ;

stmt ::= if_block | for_loop | print_func | ret | declaration | func_call  | while_loop | repeat_loop | block;


/* expressions: 
    Arithmetic
    Logical
    Relational
    Concatenation ---TODO
*/

exp ::= RO exp:x RC 
| NUMBER:x {:
                RESULT=new ValueObj(x);

            :}
| MINUS NUMBER:x  {:    RESULT=new ValueObj(-x);   :} %prec UMIN
| var:x {:  RESULT=x;  :}
| NIL
| func_call
/* Arithmetic expressions */
| exp  PLUS exp  
| exp  MINUS exp  
| exp  STAR exp  
| exp  DIV exp  
| exp HAT exp
/* Logical expressions */
| exp  AND exp 
| exp  OR exp  
| NOT exp
/* Relational expressions */
| exp  EQ EQ exp  
| exp  NOTEQ exp  
| exp  MIN exp  
| exp  MAJ exp  
| exp  MIN_EQ exp  
| exp  MAJ_EQ exp  
| RO error RC 
;

//Expression list like 2*2, 2, 4, 2^2
ass_list ::= ass_list CM ass_exp:x {: currentSymTable.expList.add(x);   :}| ass_exp:x {: currentSymTable.expList.add(x);   :};
ass_exp ::= exp:x {:
                        RESULT=x;
                :}

            | array_dec;

//1-D table

array_dec ::= BO ass_list BC | BO BC;

//local declaration

local_var_list ::= LOCAL var_list;
local_var_init ::= local_var_list EQ ass_list;


//global declaration and initialization
global_var_init ::= var_list EQ ass_list  {:

                                            for(int i=0; i<currentSymTable.varList.size(); i++){
                                                
                                                initVar(currentSymTable.varList.get(i), currentSymTable.expList.get(i));

                                            }


                                            :};

//simple assignemtn
assignment ::= var:n EQ ass_exp:x {:

                                        initVar(n, x);
:};



/*******************/
/**** VARIABLES ****/
/*******************/

//Variable list like a, b, c, d
var_list ::= var_list CM var:x {:  currentSymTable.varList.add(x) ;    :} //Store in a buffer list all the variables of var_list for later init.

            | var:x {: parser.currentSymTable.varList.add(x);   :} //Store in a buffer list all the variables of var_list for later init.


 ;

//simple var
var ::= ID:n {: 
                RESULT =currentSymTable.varTable.get(n);
                if(RESULT == null){		
		                ValueObj var = new ValueObj(n);
		                currentSymTable.varTable.put(n, var);
		                RESULT=var;
                      }
               
            :}


        | ID SO exp SC;




/***********************************/
/**** FLOW CONTROL INSTRUCTIONS ****/
/***********************************/

//block do-end

block ::= DO stmt_list END;

//loop condition
loop_cond ::=  exp ;

//loop 

for_loop ::= FOR assignment CM loop_cond CM loop_cond DO stmt_list END 
           ;

//while loop        

while_loop ::= WHILE  loop_cond  DO stmt_list END;


//repeat-until loop

repeat_loop ::= REPEAT stmt_list UNTIL loop_cond ; 



//if instruction

if_block ::= IF  exp  THEN  stmt_list  else_block END
                | IF error else_block END{: System.out.println("error");:};

else_block ::= ELSE stmt_list | ;


/*******************/
/**** FUNCTIONS ****/
/*******************/


func_list ::= | func_list function_decl;
function_decl ::= FUNCTION ID RO func_param_list RC stmt_list END;


ret ::= RETURN exp;
        //| RETURN;


print_func ::= PRINT RO print_func_args RC ;
                
                


print_func_args ::= print_func_args CM STRING | print_func_args CM exp |  STRING | exp ;

func_param_list ::= func_param_list CM exp 
                    | exp   ;


func_call ::= ID:name RO  func_param_list RC;





