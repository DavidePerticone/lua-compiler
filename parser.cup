/*
Implemented:
-Single global variable initialization with a NUMBER or with another var


NOTICE: for now, inside the functions we can just declare local variables.

*/

import java_cup.runtime.*;
import java.io.*;
import java.util.HashMap;
import java.util.Map.*;
import java.util.ArrayList;
import java.util.regex.*;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;


init with {:
   currentSymTable = new parser.SymbolTable(null); //Main symbol table for global variables included in all scopes
   funcBuffer = new StringBuffer(); //buffer for function declaration
   globalDecBuffer = new StringBuffer(); //buffer for global var declaration
   mainBuffer = new StringBuffer(); //buffer used for main function
   bwr = new BufferedWriter(new FileWriter(new File("output.ll"))); //output file
   
   /*Structure:
   Global buffer
   Function buffer
   main buffer


   */
:};


parser code {:
    
public SymbolTable currentSymTable;
public StringBuffer funcBuffer;
public StringBuffer globalDecBuffer;
public StringBuffer mainBuffer;
public BufferedWriter bwr;

public enum Type {NUMBER, TABLE, IMMEDIATE, RNUM}; //different types of values NUMBER means that the value is assigned to a var and is of type NUMBER, IMMEDIATE means it is a immediate read from file

public class SymbolTable{
        public ArrayList<ValueObj> varList;
        public ArrayList<ValueObj> expList;
        public HashMap<String, ValueObj> varTable;
        public int nargs;
        public Integer registerCount; //used as counter for SSA registers
        SymbolTable prev;
        
        public SymbolTable(SymbolTable p){
            this.varTable = new HashMap<String, ValueObj>();
            this.varList = new ArrayList<ValueObj>();
            this.expList = new ArrayList<ValueObj>();
            this.nargs = 0;
            this.prev = p;
            registerCount=1;
        }

        public ValueObj get(String s){
            for (SymbolTable sym = this; sym != null; sym = sym.prev){
                ValueObj found = sym.varTable.get(s);
                if (found != null)
                    return found;
            }
            return null;
        }
    }


public class ValueObj {

		Double value;
        public String name;
        public Type type;
        public String scope;

		public ValueObj(String name) {
			super();
			this.name = name;
            type = null;
		}

        public ValueObj(Double value){
            this.value=value;
            type = Type.IMMEDIATE;
        }

        public void setDouble(){
            this.type= Type.NUMBER;
        }

        public void setGlobal(){
            scope="@";
        }

        public void setLocal(){
            scope="%";
        }

        public void setRNUM(){
            this.type=Type.RNUM;
        }

        
  
 
    }


:};





action code {:

    public void appendFuncBuffer(String s, boolean newLine){
        funcBuffer.append(s);
        if (newLine)
            funcBuffer.append("\n");
    }

     public void appendGlobalDecBuffer(String s, boolean newLine){
        globalDecBuffer.append(s);
        if (newLine)
            globalDecBuffer.append("\n");
    }

     public void appendMainBuffer(String s, boolean newLine){
       mainBuffer.append(s);
        if (newLine)
            mainBuffer.append("\n");
    }

    public String getRegister(){
        return String.valueOf(currentSymTable.registerCount++);
    }

    public String createGlovalVarLLVM(String name, String type, String value){

            return "@"+name+" = " +"global "+type+" "+value+ ", align 8";

    }

    public String storeLLVM(String source, String sourceType, String dest, String destType, String align){
          //  store i32 %4, i32* %3, align 4
          return "store " + sourceType +" " + source+ ", " + destType+"* "+dest+", align " +align;

    }

    public String loadLLVM(String outName, String outType, String inputType, String inputName, String align ){
        // %2 = load double, double* @b, align 8

        return outName+" = " + "load " + outType+", "+inputType+"* "+inputName+", "+"align "+align;

    }

    public void initVar(ValueObj n, ValueObj x){
                                    //if the variable has never been used before, it means that must be declared
                        if(n.type == null && x.type == Type.IMMEDIATE){ //if the value to which initiliaze is an immediate
                            
                            n.setDouble(); //set type number in the variable
                            n.setGlobal();
                            //@X = global i32 17
                            //createGlovalVarLLVM(String name, String type, String value){
                            System.out.println(createGlovalVarLLVM(n.name, "double", ""+x.value));
                            appendGlobalDecBuffer(createGlovalVarLLVM(n.name, "double", ""+x.value), true); //append to the Global declaration buffer

                        }else if(n.type == Type.NUMBER && x.type == Type.IMMEDIATE){ //if type is not null, it has been already declared and must be loaded with a new value
                                //store double 6.000000e+00, double* @a, align 8
                               
                                
                                 appendMainBuffer( storeLLVM(""+x.value, "double", n.scope+n.name, "double", "8"), true); //load with a new value
                        }else if(n.type == null && x.type == Type.NUMBER){ //if new var is undeclared and we initialize with a variable already declared
                                 n.setDouble(); //set type number in the variable
                                 n.setGlobal();
                                appendGlobalDecBuffer(createGlovalVarLLVM(n.name, "double", "0.0"), true); //append to  the Global declaration buffer
                                //(String outName, String outType, String inputType, String inputName, String align )
                                String reg = getRegister(); //get a new register
                                appendMainBuffer(loadLLVM("%"+reg, "double", "double", x.scope+x.name,"8"), true); //save the value of the var into the register
                                appendMainBuffer( storeLLVM("%"+reg, "double", n.scope+n.name, "double", "8"), true); //store new var with value pointed by the variable
                        }else if(n.type == Type.NUMBER && x.type == Type.NUMBER){ //if both var have already been declared and we want to assigne one to the other
                                  String reg = getRegister();
                                 appendMainBuffer(loadLLVM("%"+reg, "double", "double", x.scope+x.name,"8"), true);
                                 appendMainBuffer(storeLLVM("%"+reg, "double", n.scope+n.name, "double", "8"), true); 
                        }else if(n.type == Type.NUMBER && x.type == Type.RNUM){ //if var already declared and RHS is a register containing a num
                            appendMainBuffer(storeLLVM("%"+x.name, "double", n.scope+n.name, "double", "8"), true); 

                        }else if(n.type == null && x.type == Type.RNUM){ //if var already declared and RHS is a register containing a num
                            n.setDouble(); //set type number in the variable
                            n.setGlobal();
                            appendGlobalDecBuffer(createGlovalVarLLVM(n.name, "double", "0.0"), true); //append to  the Global declaration buffer
                            appendMainBuffer(storeLLVM("%"+x.name, "double", n.scope+n.name, "double", "8"), true); 

                        }


    }

    public ValueObj operation(String operation, ValueObj x, ValueObj y){ //type of operation, value of first operand, value of second operand
                            ValueObj RESULT=null; //final result to return
                            String a; //variables for registers
                            String b;
                            String r;
                            if( x.type==Type.NUMBER && y.type==Type.NUMBER){ //if both operands are variables
                                a=getRegister(); //we nned three register
                                b=getRegister();
                                r=getRegister();
                                appendMainBuffer(loadLLVM("%"+a, "double", "double", x.scope+x.name, "8"), true); //load value of first
                                appendMainBuffer(loadLLVM("%"+b, "double", "double", y.scope+y.name, "8" ), true); //load value of second
                                appendMainBuffer("%"+r+" = "+ operation +" double "+"%"+a+", %"+b, true); //perform operation and save in register
                                RESULT=new ValueObj(r); //the returning value is a register containing a number, so we set the name as the number of the register
                                RESULT.setLocal();
                                RESULT.setRNUM(); //we set the type as RNUM because it is a number into a register
                            }else if(x.type==Type.IMMEDIATE && y.type==Type.IMMEDIATE){ //if both are immediates, perform operation at compile time
                                ///create switch
                                if(operation.compareTo("fadd")==0)
                                    RESULT=new ValueObj(x.value+y.value);
                                else if(operation.compareTo("fsub")==0)
                                    RESULT=new ValueObj(x.value-y.value);
                                else if(operation.compareTo("fmul")==0)
                                    RESULT=new ValueObj(x.value*y.value);
                                else if(operation.compareTo("fdiv")==0)
                                    RESULT=new ValueObj(x.value/y.value);
                                RESULT.type=Type.IMMEDIATE; //the returning value is itself and integer
                            }else if((x.type==Type.IMMEDIATE || x.type==Type.RNUM) && y.type==Type.NUMBER ){ //if one is an (immedaite or RNUM) and the other a var
                                a=getRegister(); 
                                r=getRegister();
                                if(x.type==Type.RNUM){ //if it is a RNUM it is enough to set the name to the register name with %
                                    x.name="%"+x.name;
                                }else{
                                     
                                    x.name=""+x.value; //else just use the plain value
                                     
                                }
                                appendMainBuffer(loadLLVM("%"+a, "double", "double", y.scope+y.name, "8"), true);
                                appendMainBuffer("%"+r+" = "+ operation +" double "+x.name+", %"+a, true);
                                RESULT=new ValueObj(r);
                               RESULT.setLocal();
                                 RESULT.setRNUM();
                            }else if((y.type==Type.IMMEDIATE || y.type==Type.RNUM) && x.type==Type.NUMBER){
                                 a=getRegister();
                                 r=getRegister();
                                 if(y.type==Type.RNUM){
                                    y.name="%"+y.name;
                                }else{
                                     
                                   y.name=""+y.value;
                                     
                                }
                                appendMainBuffer(loadLLVM("%"+a, "double", "double", x.scope+x.name, "8"), true);
                                appendMainBuffer("%"+r+" = "+ operation +" double "+y.name+", %"+a, true);
                                RESULT=new ValueObj(r);
                                RESULT.setLocal();
                                RESULT.setRNUM();
                            }else if(x.type==Type.RNUM && y.type==Type.RNUM ){ //if both operands are register contaning values
                                r=getRegister(); //create return register
                                appendMainBuffer("%"+r+" = "+ operation +" double "+"%"+x.name+", %"+y.name, true); //simply perform the operation
                                RESULT=new ValueObj(r);
                                RESULT.setLocal();
                                RESULT.setRNUM();//set result to RNUM
                            }else if(x.type==Type.RNUM && y.type==Type.IMMEDIATE){
                                r=getRegister(); //create return register
                                appendMainBuffer("%"+r+" = "+ operation +" double "+"%"+x.name+", "+y.value, true); //simply perform the operation
                                RESULT=new ValueObj(r);
                                RESULT.setLocal();
                                RESULT.setRNUM();//set result to RNUM

                            }else if(x.type==Type.IMMEDIATE && y.type==Type.RNUM){
                                r=getRegister(); //create return register
                                appendMainBuffer("%"+r+" = "+ operation +" double "+"%"+y.name+", "+x.value, true); //simply perform the operation
                                RESULT=new ValueObj(r);
                                RESULT.setLocal();
                                RESULT.setRNUM();//set result to RNUM

                            }
                            return RESULT;
                           
    }
:}




//Terminal tokens
terminal MIN, UMIN, MAJ, MIN_EQ, MAJ_EQ, AND, OR, NOT, SO, SC, EQ, NOTEQ;
terminal RO, RC, BO, BC, PLUS, MINUS, STAR, DIV, HAT, CM;
terminal DO, FOR, IF, ELSE, THEN, END, LOCAL;
terminal  STRING, NIL;
terminal WHILE, REPEAT, UNTIL, FUNCTION, RETURN, PRINT;
terminal String ID;
terminal Double NUMBER;
//Non terminal tokens
non terminal global_var_init, local_var, block, array_dec;
non terminal  local_var_init, local_var_list, var_list, ass_list;
non terminal for_loop, stmt_list, stmt, loop_cond, assignment;
non terminal while_loop, repeat_loop, if_block, else_block, ret;
non terminal print_func_args, func_list, instr_list, prog, finish, function_decl, print_func, func_param_list, func_call, declaration;
non terminal ValueObj var;
non terminal ValueObj ass_exp, exp;

//Precedences
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left MIN, MAJ, MIN_EQ, MAJ_EQ, EQ, NOTEQ;
precedence left PLUS, MINUS;
precedence left STAR, DIV;
precedence left NOT, UMIN;
precedence right HAT;

/***********************/
/**** GRAMMAR START ****/
/***********************/
start with prog;


prog ::= func_list {:

       

:}  stmt_list  {:
		 bwr.write(globalDecBuffer.toString());
	    bwr.write("define void @main(){\n");
        bwr.write(mainBuffer.toString());
	
	
		bwr.write("ret void\n}");
		bwr.flush();
 
		//close the stream
		bwr.close();
	
	
	
:};


/*****************************/
/**** DECLARATIONS ****/
/*****************************/

declaration ::= local_var_init | local_var_list | global_var_init | assignment;


/**********************/
/**** INSTRUCTIONS ****/
/**********************/



stmt_list ::= stmt_list stmt | stmt ;

stmt ::= if_block | for_loop | print_func | ret | declaration | func_call  | while_loop | repeat_loop | block;


/* expressions: 
    Arithmetic
    Logical
    Relational
    Concatenation ---TODO
*/

exp ::= RO exp:x RC 
| NUMBER:x {:
                RESULT=new ValueObj(x);

            :}
| MINUS NUMBER:x  {:    RESULT=new ValueObj(-x);   :} %prec UMIN
| var:x {:  RESULT=x;  :}
| NIL
| func_call
/* Arithmetic expressions */
| exp:x  PLUS exp:y  {:  RESULT=operation("fadd", x, y); :}
| exp:x  MINUS exp:y  {: RESULT=operation("fsub", x, y);  :}
| exp:x  STAR exp:y   {: RESULT=operation("fmul", x, y);  :}
| exp:x  DIV exp:y   {: RESULT=operation("fdiv", x, y);  :}
| exp:x HAT exp:y
/* Logical expressions */
| exp  AND exp 
| exp  OR exp  
| NOT exp
/* Relational expressions */
| exp  EQ EQ exp  
| exp  NOTEQ exp  
| exp  MIN exp  
| exp  MAJ exp  
| exp  MIN_EQ exp  
| exp  MAJ_EQ exp  
| RO error RC 
;

//Expression list like 2*2, 2, 4, 2^2
ass_list ::= ass_list CM ass_exp:x {: currentSymTable.expList.add(x);   :}| ass_exp:x {: currentSymTable.expList.add(x);   :};
ass_exp ::= exp:x {:
                        RESULT=x;
                :}

            | array_dec;

//1-D table

array_dec ::= BO ass_list BC | BO BC;

//local declaration

local_var_list ::= LOCAL var_list;
local_var_init ::= local_var_list EQ ass_list;


//global declaration and initialization
global_var_init ::= var_list EQ ass_list  {://check is sizes match and generate error if not
                                            for(int i=0; i<currentSymTable.varList.size(); i++){                                               
                                                initVar(currentSymTable.varList.get(i), currentSymTable.expList.get(i));
                                            }
                                            currentSymTable.varList.clear();
                                            currentSymTable.expList.clear();
                                            
                                            :};

//simple assignemtn
assignment ::= var:n EQ ass_exp:x {:initVar(n, x);:};



/*******************/
/**** VARIABLES ****/
/*******************/

//Variable list like a, b, c, d
var_list ::= var_list CM var:x {:  currentSymTable.varList.add(x) ;    :} //Store in a buffer list all the variables of var_list for later init.

            | var:x {: parser.currentSymTable.varList.add(x);   :} //Store in a buffer list all the variables of var_list for later init.


 ;

//simple var
var ::= ID:n {: 
                RESULT =currentSymTable.varTable.get(n);
                if(RESULT == null){		
		                ValueObj var = new ValueObj(n);
		                currentSymTable.varTable.put(n, var);
		                RESULT=var;
                      }
               
            :}


        | ID SO exp SC;




/***********************************/
/**** FLOW CONTROL INSTRUCTIONS ****/
/***********************************/

//block do-end

block ::= DO stmt_list END;

//loop condition
loop_cond ::=  exp ;

//loop 

for_loop ::= FOR assignment CM loop_cond CM loop_cond DO stmt_list END 
           ;

//while loop        

while_loop ::= WHILE  loop_cond  DO stmt_list END;


//repeat-until loop

repeat_loop ::= REPEAT stmt_list UNTIL loop_cond ; 



//if instruction

if_block ::= IF  exp  THEN  stmt_list  else_block END
                | IF error else_block END{: System.out.println("error");:};

else_block ::= ELSE stmt_list | ;


/*******************/
/**** FUNCTIONS ****/
/*******************/


func_list ::= | func_list function_decl;
function_decl ::= FUNCTION {: currentSymTable = new SymbolTable(currentSymTable); :}ID RO func_param_list RC stmt_list END {: currentSymTable = currentSymTable.prev;:};


/*define <retval> @<funcName> (<type>, ..., <type>) {
  ...
  ret <type> <expression>
}*/

ret ::= RETURN exp;
        //| RETURN;


print_func ::= PRINT RO print_func_args RC ;
                
                


print_func_args ::= print_func_args CM STRING | print_func_args CM exp |  STRING | exp ;

func_param_list ::= func_param_list CM exp 
                    | exp   ;


func_call ::= ID:name RO  func_param_list RC;





